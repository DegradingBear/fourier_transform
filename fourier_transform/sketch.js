let plottedPoints = [];
let path = [];
let fourierSeries = [];
let time = 0;

function setup() {
  createCanvas(1000, 800);

  console.log(
    transform(
      [
        new Complex(0,1),
        new Complex(1,2),
      ]
    )
  );

}

function draw() {
  background(0);
  stroke(255);
  strokeWeight(1);
  line(0,400,1000,400);

  canvasDraw();

  //draw every point that has been plotted as a line
  noFill();
  strokeWeight(5);
  beginShape();
  let X;
  let Y;
  for(index in plottedPoints){
    X = plottedPoints[index].re;
    Y = plottedPoints[index].im;
    vertex(X,Y);
  }
  endShape();
  strokeWeight(1);

  //uncomment and comment above to draw the plot as a series of circles , not connected
  // fill(255);
  // for(index in plottedPoints){
  //   ellipse(plottedPoints[index].re, plottedPoints[index].im, 5);
  // }

  noFill();
  stroke(100);
  let x = 0;
  let y = 400;
  for(let index in fourierSeries){
    let amp = fourierSeries[index].amp;
    ellipse(x,y,amp*2);
    let displacement = fourierSeries[index].pos(time);
    line(x,y, x+displacement.re, y+displacement.im);
    x += displacement.re;
    y += displacement.im;
  }

  stroke(255);
  path.push(new Complex(x,y));

  //draw the path generated by fourier transform
  strokeWeight(5);
  beginShape();
  for(index in path){
    let px = path[index].re;
    let py = path[index].im;
    vertex(px, py);
  }
  endShape();
  strokeWeight(1);

  //uncomment and comment above to draw fourier transform as disconnected points
  // fill(255);
  // for(index in path){
  //   ellipse(path[index].re, path[index].im, 5);
  // }

  let dt = TWO_PI/fourierSeries.length;
  time += dt;
  if(time>TWO_PI){
    time = 0;
    path=[]; //reset path after full loop
  }
}

function transform(x){
  //takes argument of a series of points (expressed as complex number objects) - x
  //applies fourier transform and returns another list of complex numbers denoting
  //the fourier series required to reproduce said series of points
  let X = [];
  let N = x.length;

  let sum = new Complex(0,0);
  for(k=0; k<N; k++){ //one element of the X list for every element of the x list
    sum.re = 0;
    sum.im = 0;

    for(n=0; n<N; n++){//for every sine wave, you have to iterate through every point
      let c = x[n].mult(eulerID( ( -1 * TWO_PI * k * n ) / N ));
      sum.add(c);
    }

    X.push(sum.copy());
  }

  //takes a transformed list of complex numbers and returns a list of equal length of eulerCirc objects that can be iterated through
  let fourier = [];

  for(let f in X){
    let amp = X[f].mag()/N;
    let phase = X[f].phase();

    fourier.push(new eCirc(f, phase, amp));
  }

  fourier.sort(function(a,b){return b.amp - a.amp});
  return fourier;
}


function canvasDraw(){
  if(mouseIsPressed){
    plottedPoints.push(new Complex(
      mouseX, mouseY
    ));

    fourierSeries = transform(plottedPoints);
    time = 0;
    path = [];
  }
}